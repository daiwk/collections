参考[https://github.com/changyeyu/LLM-RL-Visualized](https://github.com/changyeyu/LLM-RL-Visualized)，对应的书《大模型算法：强化学习、微调与对齐》）

# 概述

llm训练时的teacher forcing机制：生成第i个token的输入：
+ 推理时：是模型生成的第0到第i-1的序列
+ 训练时：训练数据中实际的token序列

例如输入的是12345，输入1的时候生成了8，那要预测3的时候，输入的就是18；而训练时输入的还是12

# SFT

## lora

+ lora的核心思想：微调前后模型的参数差异具有低秩性，所以可以用A和B两个矩阵来表示，这两个矩阵的秩是$$lora_{rank}$$
+ A一般是随机初始化，**B用0初始化**或者用很小的随机数初始化，为了保证在训练初期，lora不会对原始输出造成太大扰动
+ 参数$$lora_{alpha}$$用于缩放Lora输出，即$$W_{merge}=W+A*B*lora_{alpha}/lora_{rank}$$
+ 学习率一般开始的时候比较小，后面可以再调整，不过如果lora_alpha较大，可以适当减小学习率
+ 在推理的时候，可以先进行融合，其实就是算好$$W_{merge}$$，推理的时候直接用

## prefix-tuning

大概是在prompt的最前面加若干个虚拟token，然后这部分有自己的参数（最开始的emb，还有后面的k和v，这里的k和v都是2个mlp，先映射到小一点的d'，再映射到d），总的可训练参数量参考：

![](../assets/prefix-tuning-params.png)

## sft loss

LM head：从hidden dim映射到vocab size


# 一些常用的参数

+ temperature：**控制不同词的概率差距**。当调小时，x/T变大，然后经过exp会指数放大，这样高logit的会变得更巨大，词的差距会被拉大，所以模型的输出会更稳定，输出结果更确定；反之不同词的差距更小，输出更多样
+ top-p：**控制长尾词的概率阈值**。top cummulative probability，是一个门槛，即从第一名往下数，累加后的概率大于p时，把后面的词扔掉，剩下的词再softmax，并去采样。调低会去掉长尾，输出稳定；调高会放低门槛，输出多样

temperature和top-p虽然原理不同，但均是越大越多样，适用创作等场景；越小越稳定，适用于代码、数学